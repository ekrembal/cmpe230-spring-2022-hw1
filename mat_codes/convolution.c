#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#define EPS 0.00001
enum type{OP, NUM, MAT, VEC, SCA};typedef struct Variable {int feature;int dim1,dim2;double val[1000][1000];}Variable;struct Variable * createScalar(){Variable *newNode = (Variable*)malloc(sizeof(Variable));newNode->feature = SCA;newNode->dim1 = 1;newNode->dim2 = 1;return newNode;}struct Variable * createVector(int a){Variable *newNode = (Variable*)malloc(sizeof(Variable));newNode->feature = VEC;newNode->dim1 = a;newNode->dim2 = 1;return newNode;}struct Variable * createMatrix(int a , int b){Variable *newNode = (Variable*)malloc(sizeof(Variable));newNode->feature = MAT;newNode->dim1 = a;newNode->dim2 = b;return newNode;}struct Variable * multiplication(struct Variable * a, struct Variable * b){struct Variable* newNode = (struct Variable*)malloc(sizeof(struct Variable));if( (a->dim1 == 1 && a->dim2 == 1 ) && (b->dim1 == 1 && b->dim2 == 1)){newNode->feature = SCA;newNode->dim1=1;newNode->dim2=1;newNode->val[0][0] = a->val[0][0] * b->val[0][0];}else if( (a->dim1 == 1 && a->dim2 == 1 ) && !(b->dim1 == 1 && b->dim2 == 1) ){newNode->feature = MAT;newNode->dim1=b->dim1;newNode->dim2=b->dim2;for( int i = 0 ; i < b->dim1 ; i++ ){for( int j = 0 ; j < b->dim2 ; j++ ){newNode->val[i][j] = a->val[0][0] * b->val[i][j];}}}else if( !(a->dim1 == 1 && a->dim2 == 1 ) && (b->dim1 == 1 && b->dim2 == 1) ){newNode->feature = MAT;newNode->dim1=a->dim1;newNode->dim2=a->dim2;for( int i = 0 ; i < a->dim1 ; i++ ){for( int j = 0 ; j < a->dim2 ; j++ ){newNode->val[i][j] = b->val[0][0] * a->val[i][j];}}}else if( !(a->dim1 == 1 && a->dim2 == 1 ) && !(b->dim1 == 1 && b->dim2 == 1) ){newNode->feature = MAT;newNode->dim1=a->dim1;newNode->dim2=b->dim2;for( int i = 0 ;  i < a->dim1 ; i++ ){for( int j = 0 ; j < b->dim2 ; j++ ){newNode->val[i][j]=0;for( int k = 0 ; k < a->dim2 ; k++ ){newNode->val[i][j] += (a->val[i][k] * b->val[k][j]);}}}}return newNode;}struct Variable * generateScalarFromNumber(double var){Variable *newNode = (Variable*)malloc(sizeof(Variable));newNode->feature = SCA;newNode->dim1 = 1;newNode->dim2 = 1;newNode->val[0][0]=var;return newNode;}struct Variable * addition( struct Variable *a , struct Variable *b ){struct Variable *newNode = (struct Variable*)malloc(sizeof(struct Variable));newNode->feature = a->feature;newNode->dim1 = a->dim1;newNode->dim2 = a->dim2;for( int i = 0 ;  i < a->dim1 ; i++ ){for(int j = 0 ; j < a->dim2 ; j++ ){newNode->val[i][j] = a->val[i][j] + b->val[i][j];}}return newNode;}struct Variable * substraction(struct Variable *a, struct Variable *b){struct Variable* newNode = (struct Variable*)malloc(sizeof(struct Variable));newNode->feature = a->feature;newNode->dim1 = a->dim1;newNode->dim2 = a->dim2;for( int i = 0 ;  i < a->dim1 ; i++ ){for(int j = 0 ; j < a->dim2 ; j++ ){newNode->val[i][j] = a->val[i][j] - b->val[i][j];}}return newNode;}struct Variable * squareroot( struct Variable *a){struct Variable* newNode = (struct Variable*)malloc(sizeof(struct Variable));newNode->feature = a->feature;newNode->dim1 = 1;newNode->dim2 = 1;newNode->val[0][0]=sqrt(a->val[0][0]);return newNode;}struct Variable * transpose( struct Variable * a){struct Variable* newNode = (struct Variable*)malloc(sizeof(struct Variable));newNode->feature = a->feature;newNode->dim1 = a->dim2;newNode->dim2 = a->dim1;for( int i = 0 ; i < a->dim1 ; i++ ){for( int j = 0 ; j < a->dim2 ; j++ ){newNode->val[j][i] = a->val[i][j];}}return newNode;}double mut(double x){return (x < 0)?-x:x;}struct Variable * choose( struct Variable * expr1, struct Variable * expr2, struct Variable * expr3, struct Variable * expr4 ){if( mut(expr1->val[0][0] - 0) < EPS ){return expr2;}else if( expr1->val[0][0] > 0){return expr3;}else if( expr1->val[0][0] < 0 ){return expr4;}return expr1;}void print( struct Variable * a){for( int i = 0 ; i < a->dim1 ; i++ ){for( int  j = 0 ; j < a->dim2 ; j++ ){if((a->val[i][j] - (int)a->val[i][j])<EPS){printf("%d ",(int)a->val[i][j]);}else{printf("%lf ",a->val[i][j]);}}printf("\n");}}void printsep(){printf("----------\n");}bool isLower(struct Variable * a, struct Variable * b){return (a->val[0][0] <= b->val[0][0]);}void increase( struct Variable * a, struct Variable * b){a->val[0][0] += b->val[0][0];return;}struct Variable * getSingleIndexInt(struct Variable * a , int index ){index--;struct Variable* newNode = (struct Variable*)malloc(sizeof(struct Variable));int row = index / a->dim2;int column = index % a->dim2;newNode->dim1=1;newNode->dim2=1;newNode->feature=SCA;newNode->val[0][0]=a->val[row][column];return newNode;}struct Variable * getSingleIndex(struct Variable * a , struct Variable * index ){int temp = index->val[0][0] - 1;struct Variable* newNode = (struct Variable*)malloc(sizeof(struct Variable));int row = temp / a->dim2;int column = temp % a->dim2;newNode->dim1=1;newNode->dim2=1;newNode->feature=SCA;newNode->val[0][0]=a->val[row][column];return newNode;}struct Variable * getDoubleIndexInt(struct Variable * a , int x, int y ){struct Variable* newNode = (struct Variable*)malloc(sizeof(struct Variable));newNode->dim1=1;newNode->dim2=1;newNode->feature=SCA;newNode->val[0][0]=a->val[x - 1][y - 1];return newNode;}struct Variable * getDoubleIndex(struct Variable * a , struct Variable * x, struct Variable * y ){struct Variable* newNode = (struct Variable*)malloc(sizeof(struct Variable));newNode->dim1=1;newNode->dim2=1;newNode->feature=SCA;newNode->val[0][0]=a->val[(int)x->val[0][0] - 1][(int)y->val[0][0] - 1];return newNode;}void assign(struct Variable * a, struct Variable * b ){a->dim1 = b->dim1;a->dim2 = b->dim2;a->feature = b->feature;for( int i = 0 ; i < 999 ; i++){for( int j  = 0 ;  j  < 999 ; j++){a->val[i][j] = b->val[i][j];}}return;}void assignToFlatten(struct Variable * a , double var , int index ){int row = index / a->dim2;int column = index % a->dim2;a->val[row][column] = var ;return;}void assignToIndex(struct Variable * a, struct Variable * index, struct Variable * var  ){a->val[(int)index->val[0][0] - 1][0] = var->val[0][0];return;}void assignToDoubleIndex(struct Variable * a, struct Variable * index1, struct Variable* index2, struct Variable * var ){a->val[(int)index1->val[0][0] - 1][(int)index2->val[0][0] - 1] = var->val[0][0];return;}
int main(){
Variable *image = createMatrix(5, 5);
Variable *filter = createMatrix(3, 3);
Variable *temp = createMatrix(3, 3);
Variable *res = createMatrix(3, 3);
Variable *i = createScalar();
Variable *j = createScalar();
Variable *n = createScalar();
Variable *m = createScalar();
Variable *sum = createScalar();
Variable *filterSize = createScalar();
Variable *fzxc0WG0lVAj6AT = generateScalarFromNumber(5);
assign(n, fzxc0WG0lVAj6AT);
Variable *jjX2A9VNFsfJ4qH = generateScalarFromNumber(5);
assign(m, jjX2A9VNFsfJ4qH);
Variable *LoGBufBRBHNmNqf = generateScalarFromNumber(3);
assign(filterSize, LoGBufBRBHNmNqf);
assignToFlatten(image, 0, 0);assignToFlatten(image, 1, 1);assignToFlatten(image, 0, 2);assignToFlatten(image, 0, 3);assignToFlatten(image, 0, 4);assignToFlatten(image, 1, 5);assignToFlatten(image, 1, 6);assignToFlatten(image, 1, 7);assignToFlatten(image, 0, 8);assignToFlatten(image, 0, 9);assignToFlatten(image, 0, 10);assignToFlatten(image, 1, 11);assignToFlatten(image, 0, 12);assignToFlatten(image, 1, 13);assignToFlatten(image, 0, 14);assignToFlatten(image, 0, 15);assignToFlatten(image, 0, 16);assignToFlatten(image, 1, 17);assignToFlatten(image, 1, 18);assignToFlatten(image, 1, 19);assignToFlatten(image, 0, 20);assignToFlatten(image, 1, 21);assignToFlatten(image, 0, 22);assignToFlatten(image, 1, 23);assignToFlatten(image, 0, 24);
assignToFlatten(filter, 0, 0);assignToFlatten(filter, 1, 1);assignToFlatten(filter, 0, 2);assignToFlatten(filter, 1, 3);assignToFlatten(filter, 1, 4);assignToFlatten(filter, 1, 5);assignToFlatten(filter, 0, 6);assignToFlatten(filter, 1, 7);assignToFlatten(filter, 0, 8);
Variable *XqfK9Nxwuggw4mF = generateScalarFromNumber(1);
Variable *gqHSf71iezcBdjb = substraction(n, filterSize);
Variable *ehHGCc0Fy6fV74l = generateScalarFromNumber(1);
Variable *EHKvrLK5t5pJqPy = addition(ehHGCc0Fy6fV74l, gqHSf71iezcBdjb);
Variable *olx4OhLjzJCaRYs = generateScalarFromNumber(1);
Variable *gZQKLSjEy4CZwcD = generateScalarFromNumber(1);
Variable *VRab5y965CSUrp2 = substraction(n, filterSize);
Variable *AQWygqUNk06ONHx = generateScalarFromNumber(1);
Variable *649VOR3g7qLY34A = addition(AQWygqUNk06ONHx, VRab5y965CSUrp2);
Variable *BBKNLvwJByKkPJn = generateScalarFromNumber(1);
for(assign(i,XqfK9Nxwuggw4mF); isLower(i,EHKvrLK5t5pJqPy); increase(i,olx4OhLjzJCaRYs)){
for(assign(j,gZQKLSjEy4CZwcD); isLower(j,649VOR3g7qLY34A); increase(j,BBKNLvwJByKkPJn)){
Variable *kGR7Q0B0MwbPNRB = generateScalarFromNumber(1);
Variable *7BJI6dqpRz1glsX = generateScalarFromNumber(1);
Variable *JsDClAyQ67Rr71R = getDoubleIndex( image, i, j );
assignToDoubleIndex(temp, kGR7Q0B0MwbPNRB, 7BJI6dqpRz1glsX, JsDClAyQ67Rr71R);
Variable *83pEVYSS5RyWOLZ = generateScalarFromNumber(1);
Variable *LVXDSZ7h6HJk0tJ = generateScalarFromNumber(2);
Variable *Z4HUXbH5Xp338Xs = generateScalarFromNumber(1);
Variable *BfIewjUiks8qojm = addition(Z4HUXbH5Xp338Xs, j);
Variable *bwQ4YUInOGVfXYO = getDoubleIndex( image, i, BfIewjUiks8qojm );
assignToDoubleIndex(temp, 83pEVYSS5RyWOLZ, LVXDSZ7h6HJk0tJ, bwQ4YUInOGVfXYO);
Variable *2XleWRbjzwgnZRc = generateScalarFromNumber(1);
Variable *xRhcckQQlPEutoN = generateScalarFromNumber(3);
Variable *NwTtplfjV5Z9yBm = generateScalarFromNumber(2);
Variable *WWajJb4pssczxPD = addition(NwTtplfjV5Z9yBm, j);
Variable *zye88fNJe8BcXsq = getDoubleIndex( image, i, WWajJb4pssczxPD );
assignToDoubleIndex(temp, 2XleWRbjzwgnZRc, xRhcckQQlPEutoN, zye88fNJe8BcXsq);
Variable *B6reMIm1YyBMjfi = generateScalarFromNumber(2);
Variable *NlSUTIn5yMpo9Eo = generateScalarFromNumber(1);
Variable *OX1urOd6HsY0vPf = generateScalarFromNumber(1);
Variable *Mwqx4EQ3CR1Nxs6 = addition(OX1urOd6HsY0vPf, i);
Variable *68SR1HEuz0lFgmX = getDoubleIndex( image, Mwqx4EQ3CR1Nxs6, j );
assignToDoubleIndex(temp, B6reMIm1YyBMjfi, NlSUTIn5yMpo9Eo, 68SR1HEuz0lFgmX);
Variable *LFd0Llfiatep167 = generateScalarFromNumber(2);
Variable *f4PrLbGyikugyYq = generateScalarFromNumber(2);
Variable *gN1cZv0t1PVfQi6 = generateScalarFromNumber(1);
Variable *j21mDBcDzQx3TuS = addition(gN1cZv0t1PVfQi6, i);
Variable *zQ3tNpGkDaDJimC = generateScalarFromNumber(1);
Variable *PAtvZNE82NL2s3V = addition(zQ3tNpGkDaDJimC, j);
Variable *gvC4N8uvOQ6cVZZ = getDoubleIndex( image, j21mDBcDzQx3TuS, PAtvZNE82NL2s3V );
assignToDoubleIndex(temp, LFd0Llfiatep167, f4PrLbGyikugyYq, gvC4N8uvOQ6cVZZ);
Variable *a6XEOrULyU0ejDS = generateScalarFromNumber(2);
Variable *xH6oUB3p6HY2B3b = generateScalarFromNumber(3);
Variable *Te6N6APzGtIlTrt = generateScalarFromNumber(1);
Variable *ZZ33FWhRRb8ly1u = addition(Te6N6APzGtIlTrt, i);
Variable *ci1a1dL1jKfpK0a = generateScalarFromNumber(2);
Variable *me3SklXz1YZRhR1 = addition(ci1a1dL1jKfpK0a, j);
Variable *TGU3gtFMtJRWX5U = getDoubleIndex( image, ZZ33FWhRRb8ly1u, me3SklXz1YZRhR1 );
assignToDoubleIndex(temp, a6XEOrULyU0ejDS, xH6oUB3p6HY2B3b, TGU3gtFMtJRWX5U);
Variable *wO3XEDDDu6HvGFs = generateScalarFromNumber(3);
Variable *Qv7khFC4ReKwSvV = generateScalarFromNumber(1);
Variable *lxKYhvVuOltTOfE = generateScalarFromNumber(2);
Variable *kl4xLzcOtcSFR3J = addition(lxKYhvVuOltTOfE, i);
Variable *VaPFAjE8h826U2n = getDoubleIndex( image, kl4xLzcOtcSFR3J, j );
assignToDoubleIndex(temp, wO3XEDDDu6HvGFs, Qv7khFC4ReKwSvV, VaPFAjE8h826U2n);
Variable *B3TanCfbV4gkMxX = generateScalarFromNumber(3);
Variable *vs6tWn9ImfyZUyw = generateScalarFromNumber(2);
Variable *JH5twrNLA8jOUNP = generateScalarFromNumber(2);
Variable *K6ACYjJrzrZHxgk = addition(JH5twrNLA8jOUNP, i);
Variable *6RvYHruejSBt3h1 = generateScalarFromNumber(1);
Variable *HY1nsYP2EgUo0WG = addition(6RvYHruejSBt3h1, j);
Variable *3Bw6n8uORcGqeAX = getDoubleIndex( image, K6ACYjJrzrZHxgk, HY1nsYP2EgUo0WG );
assignToDoubleIndex(temp, B3TanCfbV4gkMxX, vs6tWn9ImfyZUyw, 3Bw6n8uORcGqeAX);
Variable *RIKUHovZVk9kmua = generateScalarFromNumber(3);
Variable *5PM8NofeJEMBFff = generateScalarFromNumber(3);
Variable *Ikm7EzqRkUCVlwV = generateScalarFromNumber(2);
Variable *U3n3o91ZGHB62VF = addition(Ikm7EzqRkUCVlwV, i);
Variable *6cqYgoruzCpvoTg = generateScalarFromNumber(2);
Variable *AFNkgCekPeBOhgB = addition(6cqYgoruzCpvoTg, j);
Variable *4fsIH3zFuL9pNMo = getDoubleIndex( image, U3n3o91ZGHB62VF, AFNkgCekPeBOhgB );
assignToDoubleIndex(temp, RIKUHovZVk9kmua, 5PM8NofeJEMBFff, 4fsIH3zFuL9pNMo);
Variable *vXRL9MuNh44MojT = generateScalarFromNumber(1);
Variable *1G2B6d8fvafnssG = generateScalarFromNumber(1);
Variable *2016Wtb2pAvxeVQ = getDoubleIndex( temp, vXRL9MuNh44MojT, 1G2B6d8fvafnssG );
Variable *H8gpAKMYXj81CyT = generateScalarFromNumber(1);
Variable *MaecgkaoDrXhZ4h = generateScalarFromNumber(1);
Variable *n2mwEEfvJOurxLI = getDoubleIndex( filter, H8gpAKMYXj81CyT, MaecgkaoDrXhZ4h );
Variable *r6e84NcGv0VNlwU = multiplication(2016Wtb2pAvxeVQ, n2mwEEfvJOurxLI);
Variable *JS6TXMh6mWrmibg = generateScalarFromNumber(1);
Variable *WJWnHb6a0RTJmja = generateScalarFromNumber(2);
Variable *5RVSVDgPmQGioCT = getDoubleIndex( temp, JS6TXMh6mWrmibg, WJWnHb6a0RTJmja );
Variable *TC1KXZbFzx6o2Av = generateScalarFromNumber(1);
Variable *PSgT8I62FKqARGC = generateScalarFromNumber(2);
Variable *Og2idwjW7b41xdq = getDoubleIndex( filter, TC1KXZbFzx6o2Av, PSgT8I62FKqARGC );
Variable *lGzKdoQIcM0lysj = multiplication(5RVSVDgPmQGioCT, Og2idwjW7b41xdq);
Variable *E8MQrVq3zC47BoX = generateScalarFromNumber(1);
Variable *No2lo5lrZUGDSro = generateScalarFromNumber(3);
Variable *KldIrfF05PlL1ss = getDoubleIndex( temp, E8MQrVq3zC47BoX, No2lo5lrZUGDSro );
Variable *LXUWTyqdnEhCxQQ = generateScalarFromNumber(1);
Variable *O4TIP8TvxVOUsBT = generateScalarFromNumber(3);
Variable *fFud4P9lD7RIPhG = getDoubleIndex( filter, LXUWTyqdnEhCxQQ, O4TIP8TvxVOUsBT );
Variable *wibcemdV7EWsjap = multiplication(KldIrfF05PlL1ss, fFud4P9lD7RIPhG);
Variable *8SrJmcKBXUr2Xmk = addition(wibcemdV7EWsjap, lGzKdoQIcM0lysj);
Variable *bPUoejZnNKJq3pv = addition(8SrJmcKBXUr2Xmk, r6e84NcGv0VNlwU);
assign(sum, bPUoejZnNKJq3pv);
Variable *ZfjdB5kAvREPwjU = generateScalarFromNumber(2);
Variable *5ORC1KEpNK8rQ8v = generateScalarFromNumber(1);
Variable *paksljPEyiSMo9R = getDoubleIndex( temp, ZfjdB5kAvREPwjU, 5ORC1KEpNK8rQ8v );
Variable *CgV5qiDbosFIvns = generateScalarFromNumber(2);
Variable *xnn53iUcUjOv3yU = generateScalarFromNumber(1);
Variable *7FyyE2DqtkRD2sg = getDoubleIndex( filter, CgV5qiDbosFIvns, xnn53iUcUjOv3yU );
Variable *9i4BkW8E5gT1EKM = multiplication(paksljPEyiSMo9R, 7FyyE2DqtkRD2sg);
Variable *Rmt7XK7gBB0b5uB = generateScalarFromNumber(2);
Variable *ZrYiIDXEsp7nPHO = generateScalarFromNumber(2);
Variable *rP7kJS36cogRln4 = getDoubleIndex( temp, Rmt7XK7gBB0b5uB, ZrYiIDXEsp7nPHO );
Variable *Kpw0MAdoD2IuLnL = generateScalarFromNumber(2);
Variable *1lOsTZjvkXahho8 = generateScalarFromNumber(2);
Variable *DCnqA3wchCWTvaX = getDoubleIndex( filter, Kpw0MAdoD2IuLnL, 1lOsTZjvkXahho8 );
Variable *SHpAdgk5UB8aYJR = multiplication(rP7kJS36cogRln4, DCnqA3wchCWTvaX);
Variable *rFVsCPBKcaj9WCV = generateScalarFromNumber(2);
Variable *DzMCBGz6ZyV1I8I = generateScalarFromNumber(3);
Variable *BQtaUrRiwVhUJq7 = getDoubleIndex( temp, rFVsCPBKcaj9WCV, DzMCBGz6ZyV1I8I );
Variable *RSRhMqrAicjRzFg = generateScalarFromNumber(2);
Variable *1hglbbiEbePRJnY = generateScalarFromNumber(3);
Variable *ShnMjmJwLiq5lfO = getDoubleIndex( filter, RSRhMqrAicjRzFg, 1hglbbiEbePRJnY );
Variable *ysG6NZBqQAJeZrE = multiplication(BQtaUrRiwVhUJq7, ShnMjmJwLiq5lfO);
Variable *wFOxJXsLTBYflIZ = addition(ysG6NZBqQAJeZrE, SHpAdgk5UB8aYJR);
Variable *gWrRHeDpOgkb7Kh = addition(wFOxJXsLTBYflIZ, 9i4BkW8E5gT1EKM);
Variable *Wi1Aly8eWWygDRD = addition(gWrRHeDpOgkb7Kh, sum);
assign(sum, Wi1Aly8eWWygDRD);
Variable *63TNH1JBv0kGvd6 = generateScalarFromNumber(3);
Variable *eFmENV73bHaxQ2m = generateScalarFromNumber(1);
Variable *lIEMtTL2uP8jj9H = getDoubleIndex( temp, 63TNH1JBv0kGvd6, eFmENV73bHaxQ2m );
Variable *ud7loxaU67ek8P5 = generateScalarFromNumber(3);
Variable *OiPflFl64shpWVr = generateScalarFromNumber(1);
Variable *Gnfz9dJ7yoyA3vJ = getDoubleIndex( filter, ud7loxaU67ek8P5, OiPflFl64shpWVr );
Variable *zRHe7YN9TvG0SfS = multiplication(lIEMtTL2uP8jj9H, Gnfz9dJ7yoyA3vJ);
Variable *Kvgiml3dwwSK3KS = generateScalarFromNumber(3);
Variable *UGlwUEpzqM8O8lQ = generateScalarFromNumber(2);
Variable *G7Rp9NNFO6lOQdv = getDoubleIndex( temp, Kvgiml3dwwSK3KS, UGlwUEpzqM8O8lQ );
Variable *z4N2kuipfI9AmCU = generateScalarFromNumber(3);
Variable *0qhJgxnNQj0IDxy = generateScalarFromNumber(2);
Variable *OsFhQ5bZVBtVZYW = getDoubleIndex( filter, z4N2kuipfI9AmCU, 0qhJgxnNQj0IDxy );
Variable *Au0WtVDTD9E4xLS = multiplication(G7Rp9NNFO6lOQdv, OsFhQ5bZVBtVZYW);
Variable *7nW8gEoVqifMVEC = generateScalarFromNumber(3);
Variable *YbvhMuQPyHilO86 = generateScalarFromNumber(3);
Variable *N4We0nDZZLueyrb = getDoubleIndex( temp, 7nW8gEoVqifMVEC, YbvhMuQPyHilO86 );
Variable *BC05Uf9H4Bjp51B = generateScalarFromNumber(3);
Variable *UCVXtjXd5tM6f5Y = generateScalarFromNumber(3);
Variable *teUcv5G451x8iem = getDoubleIndex( filter, BC05Uf9H4Bjp51B, UCVXtjXd5tM6f5Y );
Variable *105RWMWzuAZZqJK = multiplication(N4We0nDZZLueyrb, teUcv5G451x8iem);
Variable *XrMdCq4DHPb1EEy = addition(105RWMWzuAZZqJK, Au0WtVDTD9E4xLS);
Variable *BZBqwtvbCxAa6EU = addition(XrMdCq4DHPb1EEy, zRHe7YN9TvG0SfS);
Variable *IXgMXliSlv0upWH = addition(BZBqwtvbCxAa6EU, sum);
assign(sum, IXgMXliSlv0upWH);
Variable *VCvtlmeVUWENLcC = generateScalarFromNumber(5);
Variable *T3TLoPlAMxib0Fe = substraction(sum, VCvtlmeVUWENLcC);
Variable *ILFvkkw34gZX7t6 = generateScalarFromNumber(1);
Variable *26n2Xw7XD4v3laa = generateScalarFromNumber(0);
Variable *AkxFDbnSQH4Sby3 = generateScalarFromNumber(0);
Variable *UzVNC4F1uMnzLx1 = choose( T3TLoPlAMxib0Fe, ILFvkkw34gZX7t6, 26n2Xw7XD4v3laa, AkxFDbnSQH4Sby3 );
assignToDoubleIndex(res, i, j, UzVNC4F1uMnzLx1);
}}
print(res);
return 0;
}
